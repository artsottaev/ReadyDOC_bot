import os
import re
import logging
import asyncio
import tempfile
import traceback
import datetime
import difflib
import httpx
import json
from contextlib import asynccontextmanager, nullcontext
from aiogram import Bot, Dispatcher, F, types
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.redis import RedisStorage
from aiogram.enums import ParseMode, ChatAction
from aiogram.types import (
    Message, 
    FSInputFile, 
    InlineKeyboardMarkup,
    InlineKeyboardButton
)
from openai import AsyncOpenAI
from dotenv import load_dotenv
from docx import Document
from redis.asyncio import Redis
from natasha import (
    Doc,
    Segmenter,
    NewsEmbedding,
    NewsMorphTagger,
    NewsSyntaxParser,
    NewsNERTagger
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

class BotApplication:
    def __init__(self):
        self.bot = None
        self.dp = None
        self.redis = None
        self.openai_client = None
        self.states = None
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ Natasha
        self.segmenter = Segmenter()
        self.emb = NewsEmbedding()
        self.morph_tagger = NewsMorphTagger(self.emb)
        self.syntax_parser = NewsSyntaxParser(self.emb)
        self.ner_tagger = NewsNERTagger(self.emb)

    async def initialize(self):
        os.environ.pop("HTTP_PROXY", None)
        os.environ.pop("HTTPS_PROXY", None)
        os.environ.pop("ALL_PROXY", None)

        BOT_TOKEN = os.getenv("BOT_TOKEN")
        OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
        REDIS_URL = os.getenv("REDIS_URL")

        if not all([BOT_TOKEN, OPENAI_API_KEY, REDIS_URL]):
            raise EnvironmentError(
                "–ù–µ –∑–∞–¥–∞–Ω—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: "
                "BOT_TOKEN, OPENAI_API_KEY, REDIS_URL"
            )

        self.openai_client = AsyncOpenAI(
            api_key=OPENAI_API_KEY,
            http_client=httpx.AsyncClient(
                proxies=None,
                timeout=30.0,
                limits=httpx.Limits(
                    max_connections=10,
                    max_keepalive_connections=2
                )
            )
        )

        self.redis = Redis.from_url(
            REDIS_URL,
            socket_timeout=10,
            socket_connect_timeout=5,
            retry_on_timeout=True,
            decode_responses=True,
            health_check_interval=30
        )
        
        if not await self.redis.ping():
            raise ConnectionError("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ Redis")

        storage = RedisStorage(redis=self.redis)
        self.bot = Bot(token=BOT_TOKEN, parse_mode=ParseMode.HTML)
        self.dp = Dispatcher(storage=storage)

        class DocGenState(StatesGroup):
            waiting_for_initial_input = State()
            current_variable = State()
            document_review = State()
            waiting_for_special_terms = State()  # –ü–µ—Ä–µ–Ω–µ—Å–ª–∏ –≤ –∫–æ–Ω–µ—Ü
        
        self.states = DocGenState
        self.register_handlers()

    # ... (–æ—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–æ register_handlers) ...

    def register_handlers(self):
        @self.dp.message(F.text == "/start")
        async def cmd_start(message: Message, state: FSMContext):
            try:
                await state.clear()
                await message.answer(
                    "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–º–æ–≥—É —Å–æ—Å—Ç–∞–≤–∏—Ç—å —é—Ä–∏–¥–∏—á–µ—Å–∫–∏–π –¥–æ–∫—É–º–µ–Ω—Ç.\n\n"
                    "–ü—Ä–æ—Å—Ç–æ –æ–ø–∏—à–∏, –∫–∞–∫–æ–π –¥–æ–∫—É–º–µ–Ω—Ç —Ç–µ–±–µ –Ω—É–∂–µ–Ω. –ù–∞–ø—Ä–∏–º–µ—Ä:\n"
                    "<i>–ù—É–∂–µ–Ω –¥–æ–≥–æ–≤–æ—Ä –∞—Ä–µ–Ω–¥—ã –æ—Ñ–∏—Å–∞ –º–µ–∂–¥—É –ò–ü –∏ –û–û–û –Ω–∞ –≥–æ–¥</i>"
                )
                await state.set_state(self.states.waiting_for_initial_input)
            except Exception as e:
                logger.error("–û—à–∏–±–∫–∞ –≤ /start: %s\n%s", e, traceback.format_exc())
                await message.answer("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

        @self.dp.message(self.states.waiting_for_initial_input)
        async def handle_description(message: Message, state: FSMContext):
            try:
                if len(message.text) > 3000:
                    await message.answer("‚ö†Ô∏è –°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç. –£–∫–æ—Ä–æ—Ç–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞.")
                    return

                await state.update_data(initial_text=message.text)
                
                async with self.show_loading(message.chat.id, ChatAction.UPLOAD_DOCUMENT):
                    await message.answer("üß† –ì–µ–Ω–µ—Ä–∏—Ä—É—é —á–µ—Ä–Ω–æ–≤–∏–∫ –¥–æ–∫—É–º–µ–Ω—Ç–∞...")
                    
                    # –£–ª—É—á—à–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–æ–ª–µ–π
                    document = await self.generate_gpt_response(
                        system_prompt="""–¢—ã –æ–ø—ã—Ç–Ω—ã–π —é—Ä–∏—Å—Ç. –°–æ—Å—Ç–∞–≤—å —é—Ä–∏–¥–∏—á–µ—Å–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç. 
                        –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ:
                        1. –ù–µ –¥–µ–ª–∞–π –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–π –æ —Ä–æ–ª—è—Ö —Å—Ç–æ—Ä–æ–Ω (–∞—Ä–µ–Ω–¥–æ–¥–∞—Ç–µ–ª—å/–∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä) –±–µ–∑ —è–≤–Ω—ã—Ö —É–∫–∞–∑–∞–Ω–∏–π
                        2. –ï—Å–ª–∏ —Ä–æ–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω—ã —è–≤–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–π –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è: –°—Ç–æ—Ä–æ–Ω–∞ 1, –°—Ç–æ—Ä–æ–Ω–∞ 2
                        3. –Ø–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–π:
                           - –ù–∞–∑–≤–∞–Ω–∏—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π –≤ —Ñ–æ—Ä–º–∞—Ç–µ [–ù–ê–ó–í–ê–ù–ò–ï_–û–†–ì–ê–ù–ò–ó–ê–¶–ò–ò]
                           - –§–ò–û –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã—Ö –ª–∏—Ü: [–§–ò–û]
                           - –ö–æ–Ω—Ç–∞–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: [–¢–ï–õ–ï–§–û–ù], [–ê–î–†–ï–°]
                           - –î—Ä—É–≥–∏–µ —Ä–µ–∫–≤–∏–∑–∏—Ç—ã: [–ò–ù–ù], [–û–ì–†–ù], [–ü–ê–°–ü–û–†–¢] –¥–ª—è –ò–ü, [–î–û–õ–ñ–ù–û–°–¢–¨] –¥–ª—è –û–û–û
                           - –°—É–º–º—ã –∏ —Å—Ä–æ–∫–∏: [–°–£–ú–ú–ê], [–°–†–û–ö]""",
                        user_prompt=f"–°–æ—Å—Ç–∞–≤—å –¥–æ–∫—É–º–µ–Ω—Ç –ø–æ –æ–ø–∏—Å–∞–Ω–∏—é:\n\n{message.text}",
                        chat_id=message.chat.id
                    )

                filename = f"draft_{message.from_user.id}.docx"
                path = self.save_docx(document, filename)
                
                await state.update_data(document_text=document)
                await message.answer_document(FSInputFile(path))
                await message.answer(
                    "üìÑ –ß–µ—Ä–Ω–æ–≤–∏–∫ –≥–æ—Ç–æ–≤! –¢–µ–ø–µ—Ä—å –∑–∞–ø–æ–ª–Ω–∏–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —Ä–µ–∫–≤–∏–∑–∏—Ç—ã."
                )
                # –°—Ä–∞–∑—É –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—é —Ä–µ–∫–≤–∏–∑–∏—Ç–æ–≤
                await self.start_variable_filling(message, state)
                
            except Exception as e:
                logger.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: %s\n%s", e, traceback.format_exc())
                await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
                await state.clear()

        # –£–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ä—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è waiting_for_special_terms

        @self.dp.callback_query(F.data == "skip_variable")
        async def handle_skip_variable(callback: types.CallbackQuery, state: FSMContext):
            data = await state.get_data()
            index = data['current_variable_index'] + 1
            await state.update_data(current_variable_index=index)
            await callback.message.delete()
            await self.ask_next_variable(callback.message, state)

        @self.dp.callback_query(F.data == "dont_know")
        async def handle_dont_know(callback: types.CallbackQuery, state: FSMContext):
            # ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...

        @self.dp.message(self.states.current_variable)
        async def handle_variable_input(message: Message, state: FSMContext):
            # ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...

        @self.dp.callback_query(F.data == "confirm_document")
        async def handle_confirm_document(callback: types.CallbackQuery, state: FSMContext):
            await callback.message.delete()
            await self.send_final_document(callback.message, state)

        @self.dp.callback_query(F.data == "edit_document")
        async def handle_edit_document(callback: types.CallbackQuery, state: FSMContext):
            await callback.message.delete()
            await state.set_state(self.states.waiting_for_initial_input)
            await callback.message.answer("üîÑ –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞:")

        # –ù–æ–≤—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —É—Å–ª–æ–≤–∏–π –≤ –∫–æ–Ω—Ü–µ
        @self.dp.callback_query(F.data == "add_terms")
        async def handle_add_terms(callback: types.CallbackQuery, state: FSMContext):
            await callback.message.answer(
                "‚úçÔ∏è –•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –æ—Å–æ–±—ã–µ —É—Å–ª–æ–≤–∏—è? –ù–∞–ø–∏—à–∏—Ç–µ –∏—Ö –∏–ª–∏ '–Ω–µ—Ç':"
            )
            await state.set_state(self.states.waiting_for_special_terms)

        @self.dp.message(self.states.waiting_for_special_terms)
        async def handle_final_additions(message: Message, state: FSMContext):
            try:
                data = await state.get_data()
                
                if message.text.strip().lower() == "–Ω–µ—Ç":
                    await self.send_final_document(message, state)
                    return
                
                base_text = data.get("final_document", "")
                
                async with self.show_loading(message.chat.id, ChatAction.TYPING):
                    await message.answer("üîß –í–Ω–æ—à—É –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –¥–æ–∫—É–º–µ–Ω—Ç...")
                    updated_doc = await self.generate_gpt_response(
                        system_prompt="–¢—ã —é—Ä–∏–¥–∏—á–µ—Å–∫–∏–π —Ä–µ–¥–∞–∫—Ç–æ—Ä. –í–Ω–µ—Å–∏ –ø—Ä–∞–≤–∫–∏, –¥–æ–±–∞–≤–∏–≤ –æ—Å–æ–±—ã–µ —É—Å–ª–æ–≤–∏—è. –°–æ—Ö—Ä–∞–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–æ–∫—É–º–µ–Ω—Ç–∞.",
                        user_prompt=f"–î–æ–±–∞–≤—å —É—Å–ª–æ–≤–∏—è –≤ –¥–æ–∫—É–º–µ–Ω—Ç:\n{message.text}\n\n–î–æ–∫—É–º–µ–Ω—Ç:\n{base_text}",
                        chat_id=message.chat.id
                    )

                filename = f"final_{message.from_user.id}.docx"
                path = self.save_docx(updated_doc, filename)
                
                await message.answer_document(FSInputFile(path))
                await message.answer("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –æ–±–Ω–æ–≤–ª–µ–Ω!")
                await state.clear()
                
                if os.path.exists(path):
                    os.unlink(path)
                    
            except Exception as e:
                logger.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: %s\n%s", e, traceback.format_exc())
                await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
                await state.clear()

    # ... (–æ—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...

    async def prepare_final_document(self, message: Message, state: FSMContext):
        data = await state.get_data()
        document_text = data['document_text']
        filled_vars = data['filled_variables']
        
        # –ó–∞–º–µ–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
        for var in data['variables']:
            if var.startswith("---"):
                continue
                
            if var in filled_vars:
                document_text = re.sub(
                    rf'\[{re.escape(var)}\]', 
                    filled_vars[var], 
                    document_text
                )
        
        async with self.show_loading(message.chat.id, ChatAction.UPLOAD_DOCUMENT):
            # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏ —Ñ–∏–∫—Å
            reviewed_doc = await self.auto_review_and_fix(document_text, message.chat.id)
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ—Å—Ç–∏
            missing_vars = set(re.findall(r'\[(.*?)\]', reviewed_doc))
            if missing_vars:
                await message.answer(
                    f"‚ö†Ô∏è –í –¥–æ–∫—É–º–µ–Ω—Ç–µ –æ—Å—Ç–∞–ª–∏—Å—å –Ω–µ–∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –ø–æ–ª—è: {', '.join(missing_vars)}\n"
                    "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π."
                )
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
            filename = f"prefinal_{message.from_user.id}.docx"
            path = self.save_docx(reviewed_doc, filename)
            
            await state.update_data(
                final_document=reviewed_doc,
                document_path=path
            )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–æ–∫—É–º–µ–Ω—Ç –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
            await message.answer_document(FSInputFile(path))
            
            # –ù–æ–≤–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –≤–æ–ø—Ä–æ—Å–æ–º –ø—Ä–æ –æ—Å–æ–±—ã–µ —É—Å–ª–æ–≤–∏—è
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(text="‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data="confirm_document"),
                    InlineKeyboardButton(text="‚úèÔ∏è –î–æ–±–∞–≤–∏—Ç—å —É—Å–ª–æ–≤–∏—è", callback_data="add_terms")
                ],
                [
                    InlineKeyboardButton(text="üîÑ –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="edit_document")
                ]
            ])
            
            await message.answer(
                "üìù –î–æ–∫—É–º–µ–Ω—Ç –≥–æ—Ç–æ–≤! –í—ã –º–æ–∂–µ—Ç–µ:\n"
                "- –ó–∞–≤–µ—Ä—à–∏—Ç—å –∏ –ø–æ–ª—É—á–∏—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω—É—é –≤–µ—Ä—Å–∏—é\n"
                "- –î–æ–±–∞–≤–∏—Ç—å –æ—Å–æ–±—ã–µ —É—Å–ª–æ–≤–∏—è\n"
                "- –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç —Å –Ω—É–ª—è",
                reply_markup=keyboard
            )
            await state.set_state(self.states.document_review)

    async def send_final_document(self, message: Message, state: FSMContext):
        data = await state.get_data()
        document_text = data.get('final_document', '')
        path = data.get('document_path', '')
        
        if not document_text:
            await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞: –¥–æ–∫—É–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
            await state.clear()
            return
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é –≤–µ—Ä—Å–∏—é
        filename = f"final_{message.from_user.id}.docx"
        final_path = self.save_docx(document_text, filename)
        
        await message.answer_document(FSInputFile(final_path))
        await message.answer("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –≥–æ—Ç–æ–≤! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –µ–≥–æ –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º.")
        await state.clear()

        # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
        for file_path in [path, final_path]:
            if file_path and os.path.exists(file_path):
                os.unlink(file_path)

    # ... (–æ—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...

if __name__ == "__main__":
    app = BotApplication()
    try:
        asyncio.run(app.run())
    except KeyboardInterrupt:
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    except Exception as e:
        logger.critical("–§–∞—Ç–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞: %s", e)